import numpy as np  # подключаем библиотеку NumPy для работы с массивами и векторными операциями

def longest_even_sequence(arr):  # определяем функцию для поиска самой длинной последовательности четных чисел
    # преобразуем массив в булеву маску: True для четных чисел, False для остальных
    mask = (arr % 2 == 0)  # элемент четный, если остаток от деления на 2 равен 0

    # добавляем 0 в начале и конце маски, преобразуем булевы значения (True/False) в целые числа (1/0)
    # затем вычисляем разности соседних элементов, чтобы найти границы последовательностей:
    diff = np.diff(np.concatenate(([0], mask.astype(int), [0])))

    # находим индексы начала последовательностей:
    start_indices = np.where(diff == 1)[0]

    # находим индексы конца последовательностей:
    end_indices = np.where(diff == -1)[0]

    # вычисляем длины всех последовательностей: разница между индексами конца и начала:
    lengths = end_indices - start_indices

    # Если есть хотя бы одна последовательность, возвращаем её максимальную длину; иначе возвращаем 0:
    return lengths.max() if lengths.size > 0 else 0

# тестовый пример:
arr = np.array([2, 2, 1, 1, 1, 4, 4, 4, 4])
print(longest_even_sequence(arr))
